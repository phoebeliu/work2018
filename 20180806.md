# flex

1.flex & overflow

onshoreçš„ç‰›é€¼åŒäº‹æŠŠé¡¹ç›®çš„åŸºç¡€ç»„ä»¶å…¨éƒ¨åŒ…äº†ä¸€ä¸ªdirectiveè¾“å‡ºï¼Œè¿™ä¸ªdirectiveç”¨äº†display flex,ä¸”ä¸è¯´IEæœ‰å¤šå°‘å‘è®©æˆ‘ä¸€ä¸ªä¸ªå¡«äº†èµ·æ¥ï¼Œæœ€å¯æ€•çš„æ˜¯å¤–å±‚åŒ…äº†çˆ¶å±‚overflow hidden,ä½†å†…å®¹å´ç»å¸¸ä¼šå‡ºç°æº¢å‡ºæƒ…å†µï¼Œä¸ºæ­¤æˆ‘å¤§æ¦‚æ”¹äº†äº”åä¸ªbugï¼Œæ‰“è¡¥ä¸ï¼Œè¿‘æ—¥æ”¹äº†é‚£ä¸ªdirectiveï¼Œæˆ‘å»æ‰äº†æ‰€æœ‰åŸæœ‰çš„ç»“æ„å’Œflex,å…¨éƒ¨é‡å†™äº†ä¸€éï¼Œè‡ªæ­¤å‘ç°ä»¥å‰çš„è¡¥ä¸éƒ½ä¸ç”¨äº†ï¼Œä¸”IEä¸ç”¨æµ‹å°±å®Œç¾å‘ˆç°äº†ã€‚

äºæ˜¯æˆ‘æƒ³çœ‹çœ‹è¿™ä¸ªğŸ¶flexä¸ºä½•èƒ½è¶…è¿‡ä»–çˆ¹çš„overflow hiddenã€‚

https://moduscreate.com/blog/how-to-fix-overflow-issues-in-css-flex-layouts/

## The Results

Under certain circumstances overflow needs a little extra love. It turns out that there was a feature in the [flexbox specification](https://drafts.csswg.org/css-flexbox/#min-size-auto) that added an implied minimum size for flex items. This feature was removed and then re-added back into the spec at some point.

Lucky for us, the fix is an easy one. Simply add `min-height: 0;` to the flex child that has our overflow container.

```
  <div class="main-container"> // flex-direction: column;
    <div class="fixed-container">Fixed Container</div> // height: 100px;
    <div class="content-wrapper"> // min-height: 0; goes here
      <div class="overflow-container">
        <div class="overflow-content">
          Overflow Content
        </div>
      </div>
    </div>
  </div>
```

Boom! Done.

https://philipwalton.com/articles/normalizing-cross-browser-flexbox-bugs/



[PHILIP WALTONEngineer @ Google](https://philipwalton.com/)



**Update:**Â as a follow-up to this article, Iâ€™ve created the Github repoÂ [Flexbugs](https://github.com/philipwalton/flexbugs): a community curated list of cross-browser flexbox issues and their known workarounds. The goal is if youâ€™re building a website using flexbox, and something isnâ€™t working as youâ€™d expect, you can find the solution there.

### The min-height bug

In Internet Explorer 10 and 11, the `min-height` property can be used to size a flex container in the column direction, but that containerâ€™s flex item children will act as if they donâ€™t know the size of their parentâ€”as if no height has been set at all.

This is a problem for my sticky footer demo since sticky footer layouts traditionally require a `min-height` declaration of `100%` (or `100vh`) to ensure that the content area is *at least* as tall as the browser window.

Since `min-height` wasnâ€™t going to work, I needed to find another way.

### Minimum content sizing of flex items

When flex items are too big to fit inside their container, those items are instructed (by the flex layout algorithm) to shrink, proportionally, according to their `flex-shrink`property. But contrary to what many browsers allow, theyâ€™re *not* supposed to shrink indefinitely. They must always be at least as big as their minimum height or width properties declare, and if no minimum height or width properties are set, their minimum size should be the default minimum size of their content.

According to the [flexbox specification](http://www.w3.org/TR/css-flexbox/#flex-common):

> By default, flex items wonâ€™t shrink below their minimum content size (the length of the longest word or fixed-size element). To change this, set the min-width or min-height property.

Chrome, Opera, and Safari currently [ignore this instruction](http://lists.w3.org/Archives/Public/www-style/2014Dec/0249.html) and allow flex items to shrink to zero. As a result, you get content overlapping.

`è¿™å°±æ˜¯å¯æ€•çš„åŸå› ï¼ä¸ºå•¥å­ä¼šå‡ºç°é‚£äº›é»˜é»˜å¤–æº¢çš„å…ƒç´ ï¼Œå› ä¸ºä¸å†™min-width,å°±è‡ªæ‰©å±•é•¿å®½ï¼Œå¤šä¹ˆçš„å¯æ€•â€¦â€¦` 

### Unitless flex-basis

Prior to the release of IE 10, the [flexbox spec at the time](http://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flexibility) stated that a flexbox itemâ€™s preferred size required a unit when using the `flex` shorthand:

> If the <preferred-size> is â€˜0â€™, it must be specified with a unit (like â€˜0pxâ€™) to avoid ambiguity; unitless zero will either be interpreted as as one of the flexibilities, or is a syntax error.

This is no longer true in the spec, but IE 10-11 still treat it as true. If you use the declaration `flex: 1 0 0` in one of these browsers, it will be an error and the entire rule (including all the flexibility properties) will be ignored.

`ä»¥ä¸‹åŸåˆ™éœ€è¦é“­è®°åœ¨å¿ƒ`

> If youâ€™re an experienced front-end developer, you know that any solution to a cross-browser problem not only needs to work today, but it needs to continue to work long after you finish a project.

> *A solution that depends on buggy behavior is no solution at all.*

Based on everything Iâ€™ve said so far, here are my personal requirements for any acceptable alternative solution to the sticky footer layout problem. It must:

- work in all browsers[[2\]](https://philipwalton.com/articles/normalizing-cross-browser-flexbox-bugs/#footnote-2)
- continue to work as browsers fix broken behavior
- not rely on any browser-specific hack

### Using height instead of min-height

If youâ€™ve been around for a while, you may remember that Internet Explorer 6 never supported the `min-height` (or width) property. It did, however, treat `height:100%` the same way other browsers treated `min-height:100%`, so all the original sticky footer solutions would recommend setting `height:100%` in an IE 6-only stylesheet.

Knowing this, using `height:100vh` instead of `min-height:100vh` was one of the first workarounds I tried. It actually did work in IE, but it didnâ€™t work in Chrome, so I immediately wrote it off.

As it turns out, I should have read the spec closer instead of simply assuming Chrome was right and IE was wrong.

In CSS, you typically choose to use `min-height` over `height` to protect yourself from the dreaded overflow. When thereâ€™s too much content, an explicit height will mean thereâ€™s either going to be clipping, overlapping, or a scroll bar. And in many situations, those are all bad. However, when youâ€™re dealing with the body element (as you are in a sticky footer layout), a scroll bar is no big deal. Itâ€™s actually what you want. So if you define an explicit height of `100vh` on the body and thereâ€™s too much content, the end result should be the same.

So then the question is: *why didnâ€™t this work in Chrome?*



> https://philipwalton.com/

> å¤§ç¥ç½‘ç«™ï¼Œæ¯æ—¥ä¸€è¯»åŠ å…¥

### Minimum sizing bugs

Previously, I mentioned that some browsers mistakenly allow flex items to shrink to less than their default minimum content size, resulting in content overlap. This is why swapping `min-height` for `height` didnâ€™t work when I tested it in Chrome.

What should happen is the header, footer, and content elements should all shrink to their default minimum content size (but not less). If these elements (combined) have more content than can fit on the screen, the body element should overflow with a scroll bar like it usually does. The header, footer, and content elements should all render normally, one on top of the other, with no overlap.

What was happening instead is Chrome was allowing the header, footer, and content elements to shrink to smaller than their default minimum content sizes. As a result, instead of the overflow happening on the body element, it was happening on the header, footer, and content elements themselves. And since the default overflow value of those elements is `visible`, their content was overlapping with each other. The footer was fixed to the bottom of the page, and the page content was overflowing below it.

Luckily, thereâ€™s an easy solution to this problem.

The flexbox spec defines an initial `flex-shrink` value of `1` but says items should not shrink below their default minimum content size. You can get pretty much this exact same behavior by using a `flex-shrink` value of `0` instead of the default `1`.[[3\]](https://philipwalton.com/articles/normalizing-cross-browser-flexbox-bugs/#footnote-3) If your element is already being sized based on its children, and it hasnâ€™t set a `width`, `height`, or `flex-basis` value, then setting `flex-shrink:0` will render it the same wayâ€”but it will avoid this bug.

### Avoiding unitless flex-basis

The unitless `flex-basis` bug is by far the easiest of the three to work around, but itâ€™s arguably the hardest one to track down when encountered in the wild.

My original solution to the sticky footer problem applied a declaration of `flex:1` to the main content element. Since a `flex` value of `1` is shorthand for `1 1 0px`,[[4\]](https://philipwalton.com/articles/normalizing-cross-browser-flexbox-bugs/#footnote-4) and since I knew I didnâ€™t want any shrinkage going on, I decided to use `1 0 0px` instead.

This worked just fine until I tested it in IE.

The problem ended up being a combination of this IE bug and my CSS minifier: the minifier was converting `1 0 0px` to `1 0 0` (which has a unitless `flex-basis` value), so IE 10-11 ignored this declaration entirely.

> è¿™é‡Œå•ä½çš„å·®åˆ«ä¹Ÿæœ‰å¤§å‘â€¦â€¦ç®€ç›´â€¦â€¦

Once I finally discovered the root of the problem, the fix was trivial. Either set an explicit `flex-basis` value or use `0%` in the `flex` shorthand. Note, using `0%` is better than `0px`since most minifiers wonâ€™t touch percentage values for other reasons.

## Putting it all together

The following is a quick summary of the bugs discussed in this article and their respective solutions:

- `min-height` on a column flex container wonâ€™t apply to its flex item children in IE 10-11. Use `height` instead if possible.
- Chrome, Opera, and Safari do not honor the default min-content size of flex items. Set `flex-shrink` to `0` (instead of the default `1`) to avoid unwanted shrinkage.
- Do not use unitless `flex-basis` values in the `flex` shorthand because IE 10-11 will error. Also use `0%` instead of `0px` since minifiers will often convert `0px` to `0` (which is unitless and will have the same problem).

With all these bug and workarounds in mind, here is the final, alternative solution I came up with. It may not be as clean or intuitive as the way I originally promoted, but it does meet all of my requirements for an alternative solution:

- It works in all browsers.
- Itâ€™s spec compliant, so it should continue to work as bugs are fixed.
- It does not use any browser-specific hacks.

Iâ€™ve added comments to the CSS to clarify which parts are workarounds:

```
/**
 * 1. Avoid the IE 10-11 `min-height` bug.
 * 2. Set `flex-shrink` to `0` to prevent Chrome, Opera, and Safari from
 *    letting these items shrink to smaller than their content's default
 *    minimum size.
 */
.Site {
  display: flex;
  flex-direction: column;
  height: 100vh; /* 1 */
}
.Site-header,
.Site-footer {
  flex-shrink: 0; /* 2 */
}
.Site-content {
  flex: 1 0 auto; /* 2 */
}
```

To see this new solution in action, check out the updated Solved by Flexbox [sticky footer demo](http://philipwalton.github.io/solved-by-flexbox/demos/sticky-footer/).

Footnotes:Technically, if you don't need to support IE 7 and older, you can build a [sticky footer layout](http://galengidman.com/2014/03/25/responsive-flexible-height-sticky-footers-in-css/)using `display:table` that allows for unknown header/footer heights. Though clearly this is more of a hack that just happens to work cross-browser rather than an actual, forward-facing solution.When I say "all browsers" I mean all browsers that implement a version of the flexbox specification dated [March 2012](http://www.w3.org/TR/2012/WD-css3-flexbox-20120322/) or newer. In other words, it should work in all [browsers that claim to support modern flexbox](http://caniuse.com/#feat=flexbox) .Using `flex-basis:0` solves the vast majority of problems associated with this bug, but not all of them. If you want your flex-items to shrink *and* you want them to not shrink past the default content size, this solution will not work.The [March 2014](http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/) update to the flexbox spec changed the meaning of the `flex:1` shorthand from `1 1 0px` to `1 1 0%`.